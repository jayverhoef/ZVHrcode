# Create covariance matrices, R and Rhat, for the toy example of Section 5.2
u <- matrix(c(1,1,2,2,5),5,1)
v <- matrix(c(4,3,3,2,4),5,1)
R <- matrix(0,5,5)
Rhat <- R
for(i in 1:5){
 for(j in 1:5){
  dist <- sqrt((u[i,1]-u[j,1])^2+(v[i,1]-v[j,1])^2)
  if(dist<4){
   R[i,j] <- 1-(3*dist/8)+(dist^3/128)}
  if(dist<3){
   Rhat[i,j] <- 1-(3*dist/6)+(dist^3/54)}
}}

# Obtain entries of Table 5.1a
X <- matrix(1,5,1)
olswts <- solve(t(X)%*%X)%*%t(X)
glswts <- solve(t(X)%*%solve(R)%*%X)%*%t(X)%*%solve(R)
eglswts <- solve(t(X)%*%solve(Rhat)%*%X)%*%t(X)%*%solve(Rhat)

# Obtain entries of Table 5.1b
y <- matrix(c(1,0,3,1,5),5,1)
muhat <- olswts%*%y
mutilde <- glswts%*%y
mutiltil <- eglswts%*%y
sigmahat2<- (1/4)*t(y-X%*%muhat)%*%(y-X%*%muhat)
sigmatilde2 <- (1/4)*t(y-X%*%mutilde)%*%solve(R)%*%(y-X%*%mutilde)
sigmatiltil2 <- (1/4)*t(y-X%*%mutiltil)%*%solve(Rhat)%*%(y-X%*%mutiltil)

# Obtain entries of Table 5.1c
varolsmuhat <- olswts%*%t(olswts)
varolsmutilde <- glswts%*%t(glswts)
varglsmuhat <- olswts%*%R%*%t(olswts)
varglsmutilde <- glswts%*%R%*%t(glswts)

# Obtain entries of Table 5.1d
toyreg <- lm(y~X)
hatvalues(toyreg)
rstudent(toyreg)
cooks.distance(toyreg)
covratio(toyreg)
Rhalf <- eigen(R)$vectors%*%diag(sqrt(eigen(R)$values))%*%t(eigen(R)$vectors)
RhalfiX <- solve(Rhalf)%*%X
hsharp <- diag(RhalfiX%*%solve(t(RhalfiX)%*%RhalfiX)%*%t(RhalfiX))
hsharp
RiX <- solve(R)%*%X
P <- RiX%*%solve(t(RiX)%*%X)%*%t(RiX)
hstar <- diag(P)/diag(solve(R))
hstar
q <- solve(R)%*%(y-X%*%mutilde)
tcad <- (q/sqrt(diag(solve(R))*(1-hstar)))%*%(1/sqrt(sigmatilde2))
tstar <- tcad*sqrt(3/(4-tcad^2))
tstar
Dstar <- (tcad*tcad*hstar)/(1-hstar)
Dstar
covratio <- ((4-tcad*tcad)/3)/(1-hstar)
covratio

#Obtain ordinary and generalized leverages as listed on page 104
Xplanar <- cbind(X,u,v)
planarreg <- lm(y~Xplanar)
hatvalues(planarreg)
RhalfiXplanar <- solve(Rhalf)%*%Xplanar
hsharpplanar <- diag(RhalfiXplanar%*%solve(t(RhalfiXplanar)%*%RhalfiXplanar)%*%t(RhalfiXplanar))
hsharpplanar

-----------------------------------------------------------------------------------------------------

# Code for obtaining the Type I error rates associated with the red shift, as presented in Table 5.3.
# Set up a small example of 25 sites on a 5x5 square grid with unit spacing:
locx <- matrix(rep(1:5,5),ncol=1,byrow=T)
locy <- matrix(rep(1:5,each=5),ncol=1,byrow=T)

# Define a covariance structure on the grid: an exponential function with correlation 0.5 at one unit of distance
G1 <- matrix(0,25,25)
G2 <- G1
for(i in 1:25){
 for(j in 1:25){
  G1[i,j] <- 0.5^(sqrt((locx[i,1]-locx[j,1])^2+(locy[i,1]-locy[j,1])^2))
  G2[i,j] <- 0.25^(sqrt((locx[i,1]-locx[j,1])^2+(locy[i,1]-locy[j,1])^2))
}}

# Create intercept
int1 <- matrix(1,25,1)

# Simulations: simulate response and regressors, compute ols and gls estimators of intercept and slopes, and count the number of times (out of 10000) that the nominal 95% t-based confidence intervals for the slopes contains the true value (0.0).  Default setting is for y to be autocorrelated and for some of the regressors to be autocorrelated; relevant lines of codes should be replaced by lines with percent signs for the cases of non-autocorrelated y and non-autocorrelated regressors.
hold1 <- matrix(0,10000,12)
count1ols <- 0
count2ols <- 0
count3ols <- 0
count1gls <- 0
count2gls <- 0
count3gls <- 0
set.seed(5)
for(i in 1:10000){
# y <- int1+t(chol(G1))%*%rnorm(25)
y <- int1+rnorm(25)
# x1 <- t(chol(G1))%*%rnorm(25)
# x2 <- t(chol(G2))%*%rnorm(25)
x1 <- rnorm(25)
x2 <- rnorm(25)
x3 <- rnorm(25)
Xreg <- cbind(x1,x2,x3)
covXreg <- cov(Xreg)
covXreghalf <- eigen(covXreg)$vectors%*%diag(sqrt(eigen(covXreg)$values))%*%t(eigen(covXreg)$vectors)
XregcovXreghalfi <- Xreg%*%solve(covXreghalf)
X <- cbind(int1,XregcovXreghalfi)
ols <- solve(t(X)%*%X)%*%t(X)%*%y
gls <- solve(t(X)%*%solve(G1)%*%X)%*%t(X)%*%solve(G1)%*%y
olsvars <- solve(t(X)%*%X)
glsvars <- solve(t(X)%*%solve(G1)%*%X)
olss2 <- t(y-X%*%ols)%*%(y-X%*%ols)/21
glss2 <- t(y-X%*%gls)%*%solve(G1)%*%(y-X%*%gls)/21
hold1[i,1] <- ols[1,1]
hold1[i,2] <- ols[2,1]
hold1[i,3] <- ols[3,1]
hold1[i,4] <- ols[4,1]
hold1[i,5] <- olss2
hold1[i,6] <- gls[1,1]
hold1[i,7] <- gls[2,1]
hold1[i,8] <- gls[3,1]
hold1[i,9] <- gls[4,1]
hold1[i,10] <- glss2
if(ols[2,1]-2.079614*sqrt(olss2*olsvars[2,2])<0 & 0<ols[2,1]+2.079614*sqrt(olss2*olsvars[2,2])){
count1ols <- count1ols+1}
if(ols[3,1]-2.079614*sqrt(olss2*olsvars[3,3])<0 & 0<ols[3,1]+2.079614*sqrt(olss2*olsvars[3,3])){
count2ols <- count2ols+1}
if(ols[4,1]-2.079614*sqrt(olss2*olsvars[4,4])<0 & 0<ols[4,1]+2.079614*sqrt(olss2*olsvars[4,4])){
count3ols <- count3ols+1}
if(gls[2,1]-2.079614*sqrt(glss2*glsvars[2,2])<0 & 0<gls[2,1]+2.079614*sqrt(glss2*glsvars[2,2])){
count1gls <- count1gls+1}
if(gls[3,1]-2.079614*sqrt(glss2*glsvars[3,3])<0 & 0<gls[3,1]+2.079614*sqrt(glss2*glsvars[3,3])){
count2gls <- count2gls+1}
if(gls[4,1]-2.079614*sqrt(glss2*glsvars[4,4])<0 & 0<gls[4,1]+2.079614*sqrt(glss2*glsvars[4,4])){
count3gls <- count3gls+1}
}

----------------------------------------------------------------------------------------------------

# Code for the sparse matrix calculations presented in Section 5.6:
x <- rep(1:100,100)
y <- rep(1:100,each=100)
coords <- cbind(x,y)
coordsp <- coords + matrix(runif(20000,-0.5,0.5),10000,2)
distp <- matrix(0,10000,10000)
for(i in 1:10000){
 for(j in 1:10000){
  distp[i,j] <- sqrt((coordsp[i,1]-coordsp[j,1])^2+(coordsp[i,2]-coordsp[j,2])^2)
}}
Sigma <- matrix(0,10000,10000)
for(i in 1:10000){
for(j in 1:10000){
 if(distp[i,j]<2){Sigma[i,j]<-1-3*distp[i,j]/4+distp[i,j]^3/16}
}}
library(SparseM)
system.time(solve(Sigma))
system.time(as.matrix(solve(as.matrix.csr(Sigma))))





